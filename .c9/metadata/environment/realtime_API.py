{"changed":true,"filter":false,"title":"realtime_API.py","tooltip":"/realtime_API.py","value":"#!/usr/bin/python3\nimport json\nimport websocket\nimport hmac\nfrom hashlib import sha256\nfrom secrets import token_hex\nimport time\nfrom threading import Thread\nimport signal\nimport os\n\n# -------------------------------------\nkey = '\tScdrTUJ6AkYX1Fwk3u6kWe'\nsecret = 't81+1ptGH5wdkxITxxJkf21zBy+NUrVaNqaD4971zI4='\n\nend_point = 'wss://ws.lightstream.bitflyer.com/json-rpc'\n\npublic_channels = ['lightning_executions_FX_BTC_JPY',\n                  'lightning_board_snapshot_FX_BTC_JPY']\nprivate_channels = ['child_order_events', 'parent_order_events']\n# -------------------------------------\n\n\ndef quit_loop(signal, frame):\n   os._exit(0)\n\n\nclass bFwebsocket(object):\n   def __init__(self, end_point, public_channels, private_channels, key, secret):\n       self._end_point = end_point\n       self._public_channels = public_channels\n       self._private_channels = private_channels\n       self._key = key\n       self._secret = secret\n       self._JSONRPC_ID_AUTH = 1\n\n   def startWebsocket(self):\n       def on_open(ws):\n           print(\"Websocket connected\")\n\n           if len(self._private_channels) > 0:\n               auth(ws)\n\n           if len(self._public_channels) > 0:\n               params = [{'method': 'subscribe', 'params': {'channel': c}}\n                         for c in self._public_channels]\n               ws.send(json.dumps(params))\n\n       def on_error(ws, error):\n           print(error)\n\n       def on_close(ws):\n           print(\"Websocket closed\")\n\n       def run(ws):\n           while True:\n               ws.run_forever()\n               time.sleep(3)\n\n       def on_message(ws, message):\n           messages = json.loads(message)\n\n           # auth レスポンスの処理\n           if 'id' in messages and messages['id'] == self._JSONRPC_ID_AUTH:\n               if 'error' in messages:\n                   print('auth error: {}'.format(messages[\"error\"]))\n               elif 'result' in messages and messages['result'] == True:\n                   params = [{'method': 'subscribe', 'params': {'channel': c}}\n                             for c in self._private_channels]\n                   ws.send(json.dumps(params))\n\n           if 'method' not in messages or messages['method'] != 'channelMessage':\n               return\n\n           params = messages[\"params\"]\n           channel = params[\"channel\"]\n           recept_data = params[\"message\"]\n\n           if channel == 'child_order_events':\n               for r in recept_data:\n                   print(r['event_date'], r['child_order_acceptance_id'],\n                         r['event_type'], r['side'], r['price'], r['size'])\n           else:\n               print(channel, len(recept_data))\n\n       def auth(ws):\n           now = int(time.time())\n           nonce = token_hex(16)\n           sign = hmac.new(self._secret.encode(\n               'utf-8'), ''.join([str(now), nonce]).encode('utf-8'), sha256).hexdigest()\n           params = {'method': 'auth', 'params': {'api_key': self._key, 'timestamp': now,\n                                                  'nonce': nonce, 'signature': sign}, 'id': self._JSONRPC_ID_AUTH}\n           ws.send(json.dumps(params))\n\n       ws = websocket.WebSocketApp(self._end_point, on_open=on_open,\n                                   on_message=on_message, on_error=on_error, on_close=on_close)\n       websocketThread = Thread(target=run, args=(ws, ))\n       websocketThread.start()\n\n\nif __name__ == '__main__':\n   # Ctrl+Cが押された時の処理\n   signal.signal(signal.SIGINT, quit_loop)\n\n   ws = bFwebsocket(end_point, public_channels, private_channels, key, secret)\n   ws.startWebsocket()\n\n   while True:\n       time.sleep(1)\n","undoManager":{"mark":6,"position":8,"stack":[[{"start":{"row":0,"column":0},"end":{"row":109,"column":0},"action":"insert","lines":["#!/usr/bin/python3","import json","import websocket","import hmac","from hashlib import sha256","from secrets import token_hex","import time","from threading import Thread","import signal","import os","","# -------------------------------------","key = ''","secret = ''","","end_point = 'wss://ws.lightstream.bitflyer.com/json-rpc'","","public_channels = ['lightning_executions_FX_BTC_JPY',","                  'lightning_board_snapshot_FX_BTC_JPY']","private_channels = ['child_order_events', 'parent_order_events']","# -------------------------------------","","","def quit_loop(signal, frame):","   os._exit(0)","","","class bFwebsocket(object):","   def __init__(self, end_point, public_channels, private_channels, key, secret):","       self._end_point = end_point","       self._public_channels = public_channels","       self._private_channels = private_channels","       self._key = key","       self._secret = secret","       self._JSONRPC_ID_AUTH = 1","","   def startWebsocket(self):","       def on_open(ws):","           print(\"Websocket connected\")","","           if len(self._private_channels) > 0:","               auth(ws)","","           if len(self._public_channels) > 0:","               params = [{'method': 'subscribe', 'params': {'channel': c}}","                         for c in self._public_channels]","               ws.send(json.dumps(params))","","       def on_error(ws, error):","           print(error)","","       def on_close(ws):","           print(\"Websocket closed\")","","       def run(ws):","           while True:","               ws.run_forever()","               time.sleep(3)","","       def on_message(ws, message):","           messages = json.loads(message)","","           # auth レスポンスの処理","           if 'id' in messages and messages['id'] == self._JSONRPC_ID_AUTH:","               if 'error' in messages:","                   print('auth error: {}'.format(messages[\"error\"]))","               elif 'result' in messages and messages['result'] == True:","                   params = [{'method': 'subscribe', 'params': {'channel': c}}","                             for c in self._private_channels]","                   ws.send(json.dumps(params))","","           if 'method' not in messages or messages['method'] != 'channelMessage':","               return","","           params = messages[\"params\"]","           channel = params[\"channel\"]","           recept_data = params[\"message\"]","","           if channel == 'child_order_events':","               for r in recept_data:","                   print(r['event_date'], r['child_order_acceptance_id'],","                         r['event_type'], r['side'], r['price'], r['size'])","           else:","               print(channel, len(recept_data))","","       def auth(ws):","           now = int(time.time())","           nonce = token_hex(16)","           sign = hmac.new(self._secret.encode(","               'utf-8'), ''.join([str(now), nonce]).encode('utf-8'), sha256).hexdigest()","           params = {'method': 'auth', 'params': {'api_key': self._key, 'timestamp': now,","                                                  'nonce': nonce, 'signature': sign}, 'id': self._JSONRPC_ID_AUTH}","           ws.send(json.dumps(params))","","       ws = websocket.WebSocketApp(self._end_point, on_open=on_open,","                                   on_message=on_message, on_error=on_error, on_close=on_close)","       websocketThread = Thread(target=run, args=(ws, ))","       websocketThread.start()","","","if __name__ == '__main__':","   # Ctrl+Cが押された時の処理","   signal.signal(signal.SIGINT, quit_loop)","","   ws = bFwebsocket(end_point, public_channels, private_channels, key, secret)","   ws.startWebsocket()","","   while True:","       time.sleep(1)",""],"id":1}],[{"start":{"row":12,"column":7},"end":{"row":12,"column":30},"action":"insert","lines":["\tScdrTUJ6AkYX1Fwk3u6kWe"],"id":2}],[{"start":{"row":13,"column":10},"end":{"row":13,"column":54},"action":"insert","lines":["t81+1ptGH5wdkxITxxJkf21zBy+NUrVaNqaD4971zI4="],"id":3}],[{"start":{"row":13,"column":54},"end":{"row":14,"column":0},"action":"insert","lines":["",""],"id":4},{"start":{"row":14,"column":0},"end":{"row":15,"column":0},"action":"insert","lines":["",""]}],[{"start":{"row":14,"column":0},"end":{"row":15,"column":0},"action":"remove","lines":["",""],"id":5},{"start":{"row":13,"column":54},"end":{"row":14,"column":0},"action":"remove","lines":["",""]}],[{"start":{"row":13,"column":54},"end":{"row":14,"column":0},"action":"insert","lines":["",""],"id":6}],[{"start":{"row":13,"column":54},"end":{"row":14,"column":0},"action":"remove","lines":["",""],"id":7}],[{"start":{"row":13,"column":55},"end":{"row":13,"column":56},"action":"insert","lines":["g"],"id":8},{"start":{"row":13,"column":56},"end":{"row":13,"column":57},"action":"insert","lines":["i"]},{"start":{"row":13,"column":57},"end":{"row":13,"column":58},"action":"insert","lines":["t"]}],[{"start":{"row":13,"column":57},"end":{"row":13,"column":58},"action":"remove","lines":["t"],"id":9},{"start":{"row":13,"column":56},"end":{"row":13,"column":57},"action":"remove","lines":["i"]},{"start":{"row":13,"column":55},"end":{"row":13,"column":56},"action":"remove","lines":["g"]}]]},"ace":{"folds":[],"scrolltop":0,"scrollleft":0,"selection":{"start":{"row":13,"column":55},"end":{"row":13,"column":55},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1590586512991}